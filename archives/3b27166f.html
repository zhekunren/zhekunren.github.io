<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/zhekunren/blog_image/img/theme/favicon.png">
  <title>RTX_RTOS之01-CMSIS_RTOS2_Tutorial自译中文版 | zhekunのblog</title>
  <meta name="author" content="zhekun" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="RTOS, RTX" />
  
  <meta property="og:type" content="article">
<meta property="og:title" content="RTX_RTOS之01-CMSIS_RTOS2_Tutorial自译中文版">
<meta property="og:url" content="https://zhekunren.github.io/archives/3b27166f.html">
<meta property="og:site_name" content="zhekunのblog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhekunren.github.io/archives/3b27166f.htmlhttps:/cdn.jsdelivr.net/gh/zhekunren/blog_image/img/posts_covers/2022/covers_0123_6.jpg">
<meta property="article:published_time" content="2021-10-30T03:25:17.000Z">
<meta property="article:modified_time" content="2022-01-23T10:25:17.000Z">
<meta property="article:author" content="zhekun">
<meta property="article:tag" content="RTOS">
<meta property="article:tag" content="RTX">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhekunren.github.io/archives/3b27166f.htmlhttps:/cdn.jsdelivr.net/gh/zhekunren/blog_image/img/posts_covers/2022/covers_0123_6.jpg">
<meta name="twitter:site" content="@null">
  <link rel="alternate" href="atom.xml" type="application/atom+xml">
  <!-- 站点验证相关 -->
  
    
      <meta name="google-site-verification" content="3MUjsxLLUvsNMRZFuKgKTuODWqF7iUJhcAaKhiMrfGc" />
    
    
      <meta name="baidu-site-verification" content="code-xZCR5R9r7E" />
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://unpkg.com/nprogress@0.2.0/nprogress.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://unpkg.com/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/banner_1.jpg');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/bg_1.webp');
        }
      }
    
  </style>
  
  <!-- Google adsense -->
  
  <meta name="generator" content="Hexo 6.0.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-archive"></i>归档</a></li>
                                    
                                
                                    
                                        <li><a href="/categories/"><i class="fa fa-folder-open"></i>分类</a></li>
                                    
                                
                                    
                                        <li><a href="/tags/"><i class="fa fa-tags"></i>标签</a></li>
                                    
                                
                                    
                                        <li><a href="/about"><i class="fa fa-user"></i>关于</a></li>
                                    
                                
                                    
                                        <li>
                                            <a><i class="fa fa-link"></i>更多</a>
                                            <ul class="sub-menu">
                                                
                                                    
                                                
                                                    
                                                        <li><a href="/friends"><i class="fa fa-paw"></i>友链</a></li>
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://new.cnzz.com/v1/login.php?siteid=1280860084"><i class="fa fa-bar-chart"></i>访客</a></li>
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://travellings.link"><i class="fa fa-subway"></i>开往</a></li>
                                                    
                                                
                                            </ul>
                                        </li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">zhekunのblog</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <!-- <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>zhekunのblog</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div> --> 
            <!-- 
                删除banner图片，delete by zhekun，此外替换以下文件中的"320px"为"50px"，共8处。
                themes\kratos-rebirth\source\css\kratosr.min.css,
                themes\kratos-rebirth\source\maps\kratosr.min.css.map,
                themes\kratos-rebirth\src\scss\kratosr.scss
            -->
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">RTX_RTOS之01-CMSIS_RTOS2_Tutorial自译中文版</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2021-10-30</li>
                <li><i class="fa fa-user"></i> 作者 zhekun</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~22.54K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1642933517000"></time> 前，其中的内容可能需要更新。</p></div>   
            </div>
            
                <div class="kratos-post-inner-toc">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%99%E7%A8%8B"><span class="toc-text">教程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Keil-RTX5-%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5"><span class="toc-text">使用 Keil RTX5 的第一步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-CMSIS-RTOS2-API"><span class="toc-text">访问 CMSIS-RTOS2 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">启动实时操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">线程管理和优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="toc-text">多个实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-text">可连接的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-text">时间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%BB%B6%E8%BF%9F"><span class="toc-text">时间延迟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E6%97%B6%E9%97%B4%E5%BB%B6%E8%BF%9F"><span class="toc-text">绝对时间延迟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">虚拟定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%BA%BF%E7%A8%8B"><span class="toc-text">空闲线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">线程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%87%E5%BF%97"><span class="toc-text">线程标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97"><span class="toc-text">事件标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">使用信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B"><span class="toc-text">同步线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">多路复用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%9A%E5%90%88-%E9%9B%86%E5%90%88"><span class="toc-text">会合(集合)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9C"><span class="toc-text">屏障</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%AD%A6%E5%91%8A"><span class="toc-text">信号量警告</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93"><span class="toc-text">互斥体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E8%AD%A6%E5%91%8A"><span class="toc-text">互斥警告</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2"><span class="toc-text">数据交换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">扩展消息队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-text">内存池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-text">配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE"><span class="toc-text">系统配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%85%8D%E7%BD%AE"><span class="toc-text">线程配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AE%9A%E6%97%B6%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">系统定时器配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83"><span class="toc-text">相关参考</span></a></li></ol>
                </div>
            
            <hr />
            <h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>本教程介绍了在 Arm Cortex-M 微控制器上使用占用空间小的实时操作系统。如果您习惯于在小型 8 位&#x2F;16 位微控制器上编写基于过程的“C”代码，您可能会怀疑是否需要这样的操作系统。如果您不熟悉在实时嵌入式系统中使用 RTOS，您应该在放弃这个想法之前阅读本章。RTOS 的使用代表了一种更复杂的设计方法，从本质上促进了由 RTOS 应用程序编程接口 (API) 强制执行的结构化代码开发。</p>
<p>RTOS 结构允许您采用更加面向对象的设计方法，同时仍然使用“C”进行编程。RTOS 还在小型微控制器上为您提供多线程支持。这两个功能实际上在设计理念上产生了相当大的转变，使我们不再考虑程序化的“C”代码和流程图。相反，我们考虑基本的程序线程和它们之间的数据流。使用实时操作系统还有一些额外的好处，这些好处可能不会立即显现出来。由于基于 RTOS 的项目由定义明确的线程组成，因此有助于改进项目管理、代码重用和软件测试。</p>
<p>这样做的代价是 RTOS 具有额外的内存要求和增加的中断延迟。通常，Keil RTX5 RTOS 需要 500 字节的 RAM 和 5k 字节的代码，但请记住，某些 RTOS 代码无论如何都会复制到您的程序中。我们现在有一代小型低成本微控制器，它们具有足够的片上存储器和处理能力来支持 RTOS 的使用。因此，使用这种方法进行开发更容易。</p>
<p>我们将首先看看为基于 Cortex-M 的微控制器设置一个介绍性的 RTOS 项目。接下来，我们将介绍每个 RTOS 原语以及它们如何影响我们应用程序代码的设计。最后，当我们对 RTOS 的特性有了清晰的了解后，我们再仔细看看 RTOS 的配置选项。如果您习惯于在不使用 RTOS（即裸机）的情况下对微控制器进行编程，那么在您完成本教程的过程中需要了解两件重要的事情。<strong>在第一部分中，我们将专注于创建和管理线程。这里的关键概念是将它们视为并行并发对象运行。在第二部分，我们将看看如何在线程之间进行通信。在本节中，关键概念是并发线程的同步。</strong></p>
<h3 id="使用-Keil-RTX5-的第一步"><a href="#使用-Keil-RTX5-的第一步" class="headerlink" title="使用 Keil RTX5 的第一步"></a>使用 Keil RTX5 的第一步</h3><p>RTOS 本身由一个调度程序组成，该调度程序支持程序线程的循环、抢占式和协作式多任务处理，以及时间和内存管理服务。额外的 RTOS 对象支持线程间通信，包括信号线程和事件标志、信号量、互斥锁、消息传递和内存池系统。正如我们将看到的，中断处理也可以由 RTOS 内核调度的优先线程来完成。<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0gNZys2U-1635564117953)(<a target="_blank" rel="noopener" href="https://arm-software.github.io/CMSIS_5/RTOS2/html/rtos_components.png)]">https://arm-software.github.io/CMSIS_5/RTOS2/html/rtos_components.png)]</a></p>
<h3 id="访问-CMSIS-RTOS2-API"><a href="#访问-CMSIS-RTOS2-API" class="headerlink" title="访问 CMSIS-RTOS2 API"></a>访问 CMSIS-RTOS2 API</h3><p>要访问我们应用程序代码中的任何 CMSIS-RTOS2 功能，必须包含以下头文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; cmsis_os2.h &gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该头文件由 Arm 维护，作为 CMSIS-RTOS2 标准的一部分。对于 Keil RTX5，这是默认 API。其他 RTOS 将拥有自己的专有 API，但可能会提供一个包装层来实现 CMSIS-RTOS2 API，因此它们可以用于需要与 CMSIS 标准兼容的地方。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>典型的“C”程序的构建块是我们调用以执行特定过程然后返回到调用函数的函数。在 CMSIS-RTOS2 中，执行的基本单位是“线程”。线程与“C”过程非常相似，但有一些非常根本的区别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">procedure</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">        <span class="keyword">return</span>(ch);                     </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">thread</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;       </span><br><span class="line"> </span><br><span class="line">__NO_RETURN <span class="type">void</span> <span class="title function_">Thread1</span><span class="params">(<span class="type">void</span>*argument)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然我们总是从我们的“C”函数返回，但一旦启动，RTOS 线程必须包含一个循环，以便它永远不会终止，从而永远运行。您可以将线程视为在 RTOS 中运行的小型自包含程序。借助 Arm Compiler，可以使用__NO_RETURN宏优化线程。此属性降低了调用永不返回的函数的成本。</p>
<p>一个 RTOS 程序由多个线程组成，这些线程由 RTOS 调度程序控制。此调度程序使用 SysTick 计时器来生成周期性中断作为时基。调度器会为每个线程分配一定的执行时间。因此thread1将运行 5 毫秒，然后取消计划以允许thread2运行类似的时间；thread2将让位于thread3并最终将控制权传回thread1. 通过以循环方式将这些运行时片段分配给每个线程，我们可以看到所有三个线程彼此并行运行。</p>
<p>从概念上讲，我们可以将每个线程视为执行我们程序的特定功能单元，所有线程同时运行。这导致我们采用更加面向对象的设计，其中每个功能块都可以单独编码和测试，然后集成到一个完全运行的程序中。这不仅在我们最终应用程序的设计上强加了一个结构，而且还有助于调试，因为可以轻松地将特定错误隔离到特定线程。它还有助于在以后的项目中重用代码。创建线程时，还会为其分配自己的线程 ID。这是一个变量，它充当每个线程的句柄，在我们想要管理线程的活动时使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osThreadId_t id1, id2, id3;</span><br></pre></td></tr></table></figure>
<p>为了使线程切换过程发生，我们有 RTOS 的代码开销，我们必须专用 CPU 硬件定时器来提供 RTOS 时间参考。另外，每次切换正在运行的线程时，我们都要将所有线程变量的状态保存到一个线程栈中。此外，有关线程的所有运行时信息都存储在由 RTOS 内核管理的线程控制块中。因此，“上下文切换时间”，即保存当前线程状态和加载并启动下一个线程的时间，是一个至关重要的数字，将取决于 RTOS 内核和底层硬件的设计。</p>
<p>线程控制块包含有关线程状态的信息。此信息的一部分是其运行状态。在给定的系统中，只有一个线程可以运行，所有其他线程都将挂起但准备运行。RTOS 具有多种线程间通信方法（信号、信号量、消息）。在这里，一个线程可能会被挂起以等待另一个线程或中断在它恢复就绪状态之前发出信号，然后它可以被 RTOS 调度程序置于运行状态。<br><img src="https://cdn.jsdelivr.net/gh/zhekunren/blog_image/img/post/2022/EOS/RTOS/RTX/CMSIS_RTOS2_Tutorial%E8%87%AA%E8%AF%91%E4%B8%AD%E6%96%87%E7%89%881.png"><br>在任何给定时刻，一个线程可能正在运行。剩余的线程将准备好运行并由内核调度。线程也可能正在等待等待 OS 事件。发生这种情况时，它们将返回就绪状态并由内核调度。</p>
<h3 id="启动实时操作系统"><a href="#启动实时操作系统" class="headerlink" title="启动实时操作系统"></a>启动实时操作系统</h3><p>为了构建一个简单的 RTOS，我们将每个线程声明为标准的“C”函数，并为每个函数声明一个线程 ID 变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thread1</span> <span class="params">(<span class="type">void</span>)</span>;    </span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> </span><br><span class="line">osThreadId thrdID1, thrdID2;</span><br></pre></td></tr></table></figure>
<p>一旦处理器离开复位向量，我们将main()正常进入函数。<strong>进入后main()，我们必须调用osKernelInitialize()来设置 RTOS。在osKernelInitialize()函数成功完成之前，不可能调用任何 RTOS 函数。一旦osKernelInitialize()完成，我们就可以创建更多线程和其他 RTOS 对象</strong>。这可以通过创建启动器线程来完成，在下面的示例中称为app_main(). 在app_main()线程内部，我们创建了启动应用程序运行所需的所有 RTOS 线程和对象。正如我们稍后将看到的，也可以在应用程序运行时动态创建和销毁 RTOS 对象。接下来，我们可以<strong>调用osKernelStart()启动 RTOS 和调度器任务切换</strong>。您可以在启动 RTOS 之前运行您想要的任何初始化代码来设置外设和初始化硬件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span> *argument)</span> &#123;</span><br><span class="line">  T_led_ID1 = osThreadNew(led_Thread1, <span class="literal">NULL</span>, &amp;ThreadAttr_LED1);</span><br><span class="line">  T_led_ID2 = osThreadNew(led_Thread2, <span class="literal">NULL</span>, &amp;ThreadAttr_LED2);</span><br><span class="line">  osDelay(osWaitForever);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  IODIR1 = <span class="number">0x00FF0000</span>;               <span class="comment">// Do any C code you want</span></span><br><span class="line">  osKernelInitialize();              <span class="comment">// Initialize the kernel</span></span><br><span class="line">  osThreadNew(app_main, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// Create the app_main() launcher thread</span></span><br><span class="line">  osKernelStart();                   <span class="comment">// Start the RTOS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建线程时，它们也被分配了优先级。如果有许多线程准备运行并且它们都具有相同的优先级，则将以循环方式为它们分配运行时间。但是，如果具有更高优先级的线程准备好运行，RTOS 调度程序将取消调度当前运行的线程并启动高优先级线程运行。这称为基于优先级的抢占式调度。在分配优先级时，您必须小心，因为高优先级线程将继续运行，直到它进入等待状态，或者直到具有相同或更高优先级的线程准备运行为止。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>一旦 RTOS 运行，就会有许多系统调用用于管理和控制活动线程。该文档列出了所有线程管理功能。</p>
<p>正如我们在前面中看到的，该app_main()线程用作启动器线程来创建应用程序线程。这是分两个阶段完成的。首先定义一个线程结构；这允许我们定义线程操作参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">osThreadId thread1_id; <span class="comment">// thread handle</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> osThreadAttr_t threadAttr_thread1 = &#123;</span><br><span class="line">        “Name_String <span class="string">&quot;,      //Human readable Name for debugger</span></span><br><span class="line"><span class="string">    Attribute_bits Control_Block_Memory,</span></span><br><span class="line"><span class="string">    Control_Block_Size,</span></span><br><span class="line"><span class="string">    Stack_Memory,</span></span><br><span class="line"><span class="string">    Stack_Size,</span></span><br><span class="line"><span class="string">    Priority,</span></span><br><span class="line"><span class="string">    TrustZone_ID,</span></span><br><span class="line"><span class="string">    reserved&#125;;</span></span><br></pre></td></tr></table></figure>
<p>线程结构要求我们定义线程函数的名称、它的线程优先级、任何特殊属性位、它的 TrustZone_ID 和它的内存分配。这是相当多的细节，但我们将在本应用笔记结束时涵盖所有内容。一旦定义了线程结构，就可以使用osThreadNew() API 调用创建线程。然后从应用程序代码内创建线程，这通常是在app_main()线程内，但可以在任何线程内的任何点创建线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread1_id = osThreadNew(name_Of_C_Function, argument,&amp;threadAttr_thread1);</span><br></pre></td></tr></table></figure>
<p>这将创建线程并启动它运行。也可以在线程启动时将参数传递给线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> startupParameter = <span class="number">0x23</span>;</span><br><span class="line">thread1_id = osThreadNew(name_Of_C_Function, (<span class="type">uint32_t</span>)startupParameter,&amp;threadAttr_thread1);</span><br></pre></td></tr></table></figure>

<h3 id="线程管理和优先级"><a href="#线程管理和优先级" class="headerlink" title="线程管理和优先级"></a>线程管理和优先级</h3><p>创建线程时，会为其分配优先级。<strong>RTOS 调度程序使用线程的优先级来决定应该调度哪个线程运行</strong>。如果有多个线程准备运行，则优先级最高的线程将被置于运行状态。如果高优先级线程准备好运行，它将抢占低优先级正在运行的线程。重要的是，在 CPU 上运行的高优先级线程不会停止运行，除非它阻塞了 RTOS API 调用或被更高优先级的线程抢占。线程的优先级在线程结构中定义，以下优先级定义可用。默认优先级是osPriorityNormal。该osPriority_t值指定线程的优先级。</p>
<p>一旦线程开始运行，就会有少量的 RTOS 系统调用用于管理正在运行的线程。然后也可以从另一个函数或从它自己的代码中提升或降低线程的优先级。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">osStatus   <span class="title function_">osThreadSetPriority</span><span class="params">(threadID, priority)</span>;</span><br><span class="line">osPriority <span class="title function_">osThreadGetPriority</span><span class="params">(threadID)</span>;</span><br></pre></td></tr></table></figure>
<p>除了创建线程，一个线程还可以从 RTOS 中删除另一个活动线程。同样，我们使用线程 ID 而不是线程的函数名称。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osStatus = osThreadTerminate (threadID1);</span><br></pre></td></tr></table></figure>
<p>如果一个线程想要终止自己，那么有一个专用的退出函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osThreadExit ( <span class="type">void</span> )</span><br></pre></td></tr></table></figure>
<p>最后，还有一种线程切换的特殊情况，即正在运行的线程将控制权传递给下一个具有相同优先级的就绪线程。这用于实现称为协作线程切换的第三种调度形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osStatus <span class="title function_">osThreadYield</span><span class="params">()</span>;  <span class="comment">//switch to next ready to run thread at the same priority</span></span><br></pre></td></tr></table></figure>

<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>创建每个线程时，会为其分配自己的堆栈，用于在上下文切换期间存储数据。这不应与原生 Cortex-M 处理器堆栈混淆；它实际上是分配给线程的内存块。RTOS 配置文件中定义了默认堆栈大小（我们稍后会看到），除非我们覆盖它以分配自定义大小，否则该内存量将分配给每个线程。如果线程定义结构中的堆栈大小值设置为零，则将默认堆栈大小分配给线程。如有必要，可以通过在线程结构中定义更大的堆栈大小来为线程提供额外的内存资源。Keil RTX5 支持多种内存模型来分配此线程内存。默认模型是全局内存池。在这个模型中，每个被创建的RTOS对象(线程、消息队列、信号量等)都从一个内存块中分配内存。</p>
<p>如果一个对象被销毁，它所分配的内存将返回到内存池。这具有内存重用的优点，但也引入了可能出现的内存碎片问题。</p>
<p>全局内存池的大小在配置文件中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OS_DYNAMIC_MEM_SIZE         4096</span></span><br></pre></td></tr></table></figure>
<p>每个线程的默认堆栈大小在线程部分定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OS_STACK_SIZE               256</span></span><br></pre></td></tr></table></figure>
<p>还可以为每种不同类型的 RTOS 对象定义对象特定的内存池。在此模型中，您可以定义特定对象类型的最大数量及其内存要求。然后 RTOS 计算并保留所需的内存使用量。</p>
<p>通过启用配置文件每个部分中提供的“对象特定内存”选项，对象特定模型再次在 RTOS 配置文件中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OS_SEMAPHORE_OBJ_MEM 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_SEMAPHORE_NUM 1</span></span><br></pre></td></tr></table></figure>
<p>在需要固定内存分配的简单对象的情况下，我们只需要定义给定对象类型的最大数量。对于更复杂的对象（例如线程），我们需要定义所需的内存使用量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OS_THREAD_OBJ_MEM 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_THREAD_NUM 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_THREAD_DEF_STACK_NUM 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_THREAD_USER_STACK_SIZE 1024</span></span><br></pre></td></tr></table></figure>
<p>要对线程使用特定于对象的内存分配模型，我们必须提供整体线程内存使用情况的详细信息。最后，可以静态分配线程堆栈内存。这对于必须严格定义内存使用的安全相关系统很重要。</p>
<h3 id="多个实例"><a href="#多个实例" class="headerlink" title="多个实例"></a>多个实例</h3><p>RTOS 的一个有趣的可能性是您可以创建相同基本线程代码的多个运行实例。例如，您可以编写一个线程来控制 UART，然后创建相同线程代码的两个运行实例。在这里，UART 代码的每个实例都可以管理不同的 UART。然后我们可以创建分配给不同线程句柄的线程的两个实例。还传递了一个参数，以允许每个实例识别它负责的 UART。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UART1 (void *) 1UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART2 (void *) 2UL</span></span><br><span class="line"> </span><br><span class="line">ThreadID_1_0 = osThreadNew (thread1, UART1, &amp;ThreadAttr_Task1);</span><br><span class="line">ThreadID_1_1 = osThreadNew (thread1, UART0, &amp;ThreadAttr_Task1);</span><br></pre></td></tr></table></figure>

<h3 id="可连接的线程"><a href="#可连接的线程" class="headerlink" title="可连接的线程"></a>可连接的线程</h3><p>CMSIS-RTOS2 中的一个新功能是能够在“可连接”状态下创建线程。这允许作为标准线程创建和执行 thead。此外，第二个线程可以通过调用osThreadJoin()加入它。这将导致第二个线程取消调度并保持等待状态，直到已加入的线程终止。这允许创建一个临时的可连接线程，该线程将从全局内存池中获取一块内存，该线程可以执行一些处理然后终止，将内存释放回内存池。可以通过设置线程属性结构中的可连接属性位来创建可连接线程，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> osThreadAttr_t ThreadAttr_worker = &#123;</span><br><span class="line">        .attr_bits = osThreadJoinable</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建线程后，它将按照与“普通”线程相同的规则执行。任何其他线程都可以通过使用操作系统调用加入它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osThreadJoin (&lt; joinable_thread_handle &gt;);</span><br></pre></td></tr></table></figure>
<p>一旦osThreadJoin（）被调用，该线程将取消调度，并进入等待状态，直到可连接线程终止。</p>
<h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>除了将您的应用程序代码作为线程运行之外，RTOS 还提供了一些可以通过 RTOS 系统调用访问的计时服务。</p>
<h4 id="时间延迟"><a href="#时间延迟" class="headerlink" title="时间延迟"></a>时间延迟</h4><p>这些计时服务中最基本的是一个简单的计时器延迟功能。这是在您的应用程序中提供时序延迟的一种简单方法。尽管 RTOS 内核大小被引用为 5 KB，但延迟循环和简单调度循环等功能通常是非 RTOS 应用程序的一部分，无论如何都会消耗代码字节，因此 RTOS 的开销可能比它立即出现的要少。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">osDelay</span> <span class="params">(<span class="type">uint32_t</span> ticks)</span></span><br></pre></td></tr></table></figure>
<p>此调用会将调用线程置于 WAIT_DELAY 状态指定的毫秒数。调度程序会将执行传递给处于 READY 状态的下一个线程。</p>
<p>当计时器到期时，线程将离开 WAIT_DELAY 状态并移动到 READY 状态。当调度程序将线程移动到 RUNNING 状态时，线程将恢复运行。如果线程随后继续执行而没有任何进一步阻塞 OS 调用，它将在其时间片结束时被取消调度并置于就绪状态，假设另一个具有相同优先级的线程已准备好运行。</p>
<h4 id="绝对时间延迟"><a href="#绝对时间延迟" class="headerlink" title="绝对时间延迟"></a>绝对时间延迟</h4><p>除了osDelay()函数从调用它的那一刻开始给出相对时间延迟之外，还有一个延迟函数可以暂停线程直到特定时间点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osStatus <span class="title function_">osDelayUntil</span> <span class="params">(<span class="type">uint32_t</span> ticks)</span>  </span><br></pre></td></tr></table></figure>
<p>该osDelayUntil（） ，直到内核定时器的具体值达到蜱功能将停止一个线程。有许多内核函数允许您读取当前的 SysTick 计数和内核滴答计数。<br><img src="https://cdn.jsdelivr.net/gh/zhekunren/blog_image/img/post/2022/EOS/RTOS/RTX/CMSIS_RTOS2_Tutorial%E8%87%AA%E8%AF%91%E4%B8%AD%E6%96%87%E7%89%882.png"></p>
<h4 id="虚拟定时器"><a href="#虚拟定时器" class="headerlink" title="虚拟定时器"></a>虚拟定时器</h4><p>CMSIS-RTOS API 可用于定义任意数量的虚拟计时器，用作倒计时计时器。当它们到期时，它们将运行用户回调函数来执行特定操作。每个计时器都可以配置为单次或重复计时器。首先定义一个定时器结构来创建一个虚拟定时器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> osThreadAttr_t ThreadAttr_app_main = &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> * name <span class="comment">// symbolic name of the timer</span></span><br><span class="line">  <span class="type">uin32_t</span> attr_bits <span class="comment">// None</span></span><br><span class="line">  <span class="type">void</span>* cb_mem      <span class="comment">// pointer to memory for control block</span></span><br><span class="line">  <span class="type">uint32_t</span> cb_size  <span class="comment">// size of memory control block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这定义了计时器的名称和回调函数的名称。然后必须由 RTOS 线程实例化计时器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">osTimerId_t timer0_handle;</span><br><span class="line">timer0_handle = osTimerNew (&amp;callback, osTimerPeriodic ,( <span class="type">void</span> *)&lt;parameter&gt;, &amp;timerAttr_timer0);</span><br></pre></td></tr></table></figure>
<p>这将创建计时器并将其定义为周期性计时器或单次计时器 ( osTimerOnce() )。当计时器到期时，下一个参数将参数传递给回调函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osTimerStart (timer0_handle,<span class="number">0x100</span>);</span><br></pre></td></tr></table></figure>
<p>然后可以在线程中的任何点启动计时器，计时器启动函数通过其句柄调用计时器并定义以内核滴答为单位的计数周期。</p>
<h4 id="空闲线程"><a href="#空闲线程" class="headerlink" title="空闲线程"></a>空闲线程</h4><p>RTOS 提供的最终计时器服务并不是真正的计时器，但这可能是讨论它的最佳场所。如果在我们的 RTOS 程序期间，我们没有线程运行，也没有线程准备运行（例如，它们都在等待延迟函数），那么 RTOS 将开始运行空闲线程。该线程在 RTOS 启动并以最低优先级运行时自动创建。空闲线程函数位于 RTX_Config.c 文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__WEAK __NO_RETURN <span class="type">void</span> <span class="title function_">osRtxIdleThread</span> <span class="params">(<span class="type">void</span> *argument)</span> &#123;</span><br><span class="line">  (<span class="type">void</span>)argument;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以向该线程添加任何代码，但它必须遵守与用户线程相同的规则。空闲恶魔的最简单用途是在微控制器不执行任何操作时将其置于低功耗模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__WEAK __NO_RETURN <span class="type">void</span> <span class="title function_">osRtxIdleThread</span> <span class="params">(<span class="type">void</span> *argument)</span> &#123;</span><br><span class="line">  (<span class="type">void</span>)argument;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    __WFE();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来会发生什么取决于微控制器中选择的电源模式。至少，CPU 将暂停，直到 SysTick 计时器产生中断并且调度程序的执行将恢复。如果有线程准备运行，则应用程序代码的执行将恢复。否则，空闲的恶魔将重新进入，系统将重新进入休眠状态。</p>
<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>到目前为止，我们已经看到了如何将应用程序代码定义为独立线程，以及如何访问 RTOS 提供的计时服务。在实际应用程序中，我们需要能够在线程之间进行通信以使应用程序有用。为此，典型的 RTOS 支持多个不同的通信对象，这些对象可用于将线程链接在一起以形成有意义的程序。CMSIS-RTOS2 API 支持与线程和事件标志、信号量、互斥体、邮箱和消息队列的线程间通信。在第一部分中，关键概念是并发性。在本节中，关键概念是同步多个线程的活动。</p>
<h4 id="线程标志"><a href="#线程标志" class="headerlink" title="线程标志"></a>线程标志</h4><p>Keil RTX5 支持每个线程最多三十二个线程标志。这些线程标志存储在线程控制块中。可以暂停线程的执行，直到系统中的另一个线程设置了特定线程标志或线程标志组。</p>
<p>该osThreadFlagsWait（）系统调用将暂停线程的执行，并把它放入wait_evnt状态。在osThreadFlagsWait() API 调用中设置的至少一个标志被设置后，线程的执行才会开始。也可以定义一个周期性超时，在此之后等待线程将移回就绪状态，以便在被调度程序选中时可以恢复执行。osWaitForever (0xFFFF) 的值定义了无限超时时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osEvent <span class="title function_">osThreadFlagsWait</span> <span class="params">(<span class="type">int32_t</span> flags,<span class="type">int32_t</span> options,<span class="type">uint32_t</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<p>线程标志选项如下：<br><img src="https://cdn.jsdelivr.net/gh/zhekunren/blog_image/img/post/2022/EOS/RTOS/RTX/CMSIS_RTOS2_Tutorial%E8%87%AA%E8%AF%91%E4%B8%AD%E6%96%87%E7%89%883.png"></p>
<p>如果指定了标志模式，则当任何一个指定标志被设置（逻辑或）时，线程将恢复执行。如果使用osFlagsWaitAll选项，则必须设置模式中的所有标志（逻辑与）。任何线程都可以在任何其他线程上设置标志，并且线程可以清除自己的标志：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">osThredFlagsSet</span> <span class="params">(osThreadId_t  thread_id, <span class="type">int32_t</span> flags)</span>;</span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">osThreadFlagsClear</span> <span class="params">(<span class="type">int32_t</span> signals)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="事件标志"><a href="#事件标志" class="headerlink" title="事件标志"></a>事件标志</h4><p>事件标志的操作方式与线程标志类似，但必须创建，然后充当所有正在运行的线程都可以使用的全局 RTOS 对象。</p>
<p>首先，我们需要创建一组事件标志，这与创建线程的过程类似。我们定义了一个事件标志属性结构。属性结构定义了 ASCII 名称字符串、属性位和内存滞留。如果我们使用的是静态内存模型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">osEventFlagsAttr_t &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;   <span class="comment">///&lt; name of the event flags</span></span><br><span class="line">  <span class="type">uint32_t</span> attr_bits; <span class="comment">///&lt; attribute bits (none)</span></span><br><span class="line">  <span class="type">void</span> *cb_mem;       <span class="comment">///&lt; memory for control block</span></span><br><span class="line">  <span class="type">uint32_t</span> cb_size;   <span class="comment">///&lt; size of provided memory for control block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来我们需要一个句柄来控制对事件标志的访问：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osEventFlagsId_t EventFlag_LED;</span><br></pre></td></tr></table></figure>
<p>然后我们可以创建事件标志对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventFlag_LED = osEventFlagsNew (&amp;EventFlagAttr_LED);</span><br></pre></td></tr></table></figure>

<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>与线程标志一样，信号量是一种在两个或多个线程之间同步活动的方法。简而言之，信号量是一个容纳多个标记的容器。当线程执行时，它将到达 RTOS 调用以获取信号量标记。如果信号量包含一个或多个标记，线程将继续执行并且信号量中的标记数量将减一。如果信号量中当前没有标记，则线程将处于等待状态，直到有标记可用。在执行过程中的任何时候，线程都可以向信号量添加一个标记，导致其标记计数增加 1。</p>
<p>上图说明了使用信号量来同步两个线程。首先，必须使用初始标记计数创建和初始化信号量。在这种情况下，信号量是用单个标记初始化的。两个线程都将运行并到达其代码中的某个点，在该点它们将尝试从信号量获取标记。到达这一点的第一个线程将从信号量中获取标记并继续执行。第二个线程也将尝试获取标记，但由于信号量是空的，它将停止执行并进入等待状态，直到信号量标记可用。</p>
<p>同时，执行线程可以将标记释放回信号量。当这种情况发生时，等待线程将获取标记并离开等待状态进入就绪状态。一旦处于就绪状态，调度程序会将线程置于运行状态，以便线程可以继续执行。虽然信号量有一组简单的操作系统调用，但它们可能是更难完全理解的操作系统对象之一。在本节中，我们将首先了解如何将信号量添加到 RTOS 程序，然后继续了解最有用的信号量应用程序。</p>
<p>要在 CMSIS-RTOS 中使用信号量，您必须首先声明信号量属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">osSemaphoreAttr_t &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;   <span class="comment">///&lt; name of the semaphore</span></span><br><span class="line">  <span class="type">uint32_t</span> attr_bits; <span class="comment">///&lt; attribute bits (none)</span></span><br><span class="line">  <span class="type">void</span> *cb_mem;       <span class="comment">///&lt; memory for control block</span></span><br><span class="line">  <span class="type">uint32_t</span> cb_size;   <span class="comment">///&lt; size of provided memory for control block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来声明信号量句柄：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osSemaphoreId_t sem1;</span><br></pre></td></tr></table></figure>
<p>然后在一个线程中，信号量容器可以用许多标记初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem1 = osSemaphoreNew (maxTokenCount,initalTokencount,&amp; osSemaphoreAttr_t );</span><br></pre></td></tr></table></figure>
<p>了解信号量标记也可能在线程运行时创建和销毁很重要。因此，例如，您可以使用零标记初始化一个信号量，然后使用一个线程在信号量中创建标记，而另一个线程将它们删除。这允许您将线程设计为生产者和消费者线程。</p>
<p>一旦信号量被初始化，就可以以类似于事件标志的方式获取标记并将其发送到信号量。所述osSemaphoreAcquire（）调用用于阻塞线程旗语标记可用直到。超时时间也可以指定为 0xFFFF 是无限等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osStatus <span class="title function_">osSemaphoreAcquire</span> <span class="params">( osSemaphoreId_t semaphore_id, <span class="type">uint32_t</span> ticks)</span>;</span><br></pre></td></tr></table></figure>
<p>一旦线程使用完信号量资源，它就可以向信号量容器发送一个标记：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osStatus <span class="title function_">osSemaphoreRelease</span> <span class="params">( osSemaphoreId_t semaphore_id)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="使用信号量"><a href="#使用信号量" class="headerlink" title="使用信号量"></a>使用信号量</h5><p>尽管信号量具有一组简单的操作系统调用，但它们具有广泛的同步应用程序。这使得它们可能是最难理解的 RTOS 对象。在本节中，我们将了解信号量的最常见用途。这些摘自Allen B. Downey 的免费书籍“The Little Book of Semaphores”。</p>
<h5 id="同步线程"><a href="#同步线程" class="headerlink" title="同步线程"></a>同步线程</h5><p>同步两个线程的执行是信号量最简单的用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">osSemaphoreId_t sem1;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> osSemaphoreAttr_t semAttr_SEM1 = &#123;</span><br><span class="line">    .name = <span class="string">&quot;SEM1&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  sem1 = osSemaphoreNew(<span class="number">5</span>, <span class="number">0</span>, &amp;semAttr_SEM1);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    FuncA();</span><br><span class="line">    osSemaphoreRelease(sem1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    osSemaphoreAcquire(sem1, osWaitForever);</span><br><span class="line">    FuncB();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，信号量用于确保FuncA()中的代码在FuncB()中的代码之前执行。</p>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>多路复用用于限制可以访问代码关键部分的线程数。例如，这可能是一个访问内存资源的例程，并且只能支持有限数量的调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">osSemaphoreId_t multiplex;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> osSemaphoreAttr_t semAttr_Multiplex = &#123;</span><br><span class="line">    .name = <span class="string">&quot;SEM1&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  multiplex = osSemaphoreCreate(<span class="number">5</span>, <span class="number">5</span>, &amp;semAttr_Multiplex);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    osSemaphoreAcquire(multiplex, osWaitForever);</span><br><span class="line">    processBuffer();</span><br><span class="line">    osSemaphoreRelease(multiplex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们用五个标记初始化多路信号量。在线程可以调用该processBuffer()函数之前，它必须获得一个信号量标记。一旦函数完成，标记被发送回信号量。如果超过五个线程尝试调用processBuffer()，则第六个线程必须等待直到线程完成processBuffer()并返回其标记。因此，多路信号量确保最多五个线程可以processBuffer()“同时”调用该函数。</p>
<h5 id="会合-集合"><a href="#会合-集合" class="headerlink" title="会合(集合)"></a>会合(集合)</h5><p>信号量信号的一种更通用的形式是集合点。集合点确保两个线程到达某个执行点。两者都不能继续，直到两者都到达会合点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">osSemaphoreId_t arrived1, arrived2;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> osSemaphoreAttr_t semAttr_Arrived1 = &#123;</span><br><span class="line">    .name = <span class="string">&quot;Arr1&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> osSemaphoreAttr_t semAttr_Arrived2 = &#123;</span><br><span class="line">    .name = <span class="string">&quot;Arr2&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  arrived1 = osSemaphoreNew(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  arrived1 = osSemaphoreNew(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    FuncA1();</span><br><span class="line">    osSemaphoreRelease(arrived1);</span><br><span class="line">    osSemaphoreAcquire(arrived2, osWaitForever);</span><br><span class="line">    FuncA2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    FuncB1();</span><br><span class="line">    os_sem_Release(arrived2);</span><br><span class="line">    os_sem_Acquire(arrived1, osWaitForever);</span><br><span class="line">    FuncB2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述情况下，两个信号量将确保两个线程会合，然后继续执行FuncA2()和FuncB2()。</p>
<h5 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h5><p>尽管集合点对于同步代码执行非常有用，但它仅适用于两个函数。屏障是一种更通用的集合形式，用于同步多个线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">osSemaphoreId_t count, barrier;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> osSemaphoreAttr_t semAttr_Counter = &#123;</span><br><span class="line">    .name = <span class="string">&quot;Counter&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> osSemaphoreAttr_t semAttr_Barier = &#123;</span><br><span class="line">    .name = <span class="string">&quot;Barrier&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  Turnstile_In = osSemaphoreNew(<span class="number">5</span>, <span class="number">0</span>, &amp;semAttr_SEM_In);</span><br><span class="line">  Turnstile_Out = osSemaphoreNew(<span class="number">5</span>, <span class="number">1</span>, &amp;semAttr_SEM_Out);</span><br><span class="line">  Mutex = osSemaphoreNew(<span class="number">1</span>, <span class="number">1</span>, &amp;semAttr_Mutex);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    osSemaphoreAcquire(Mutex, osWaitForever); <span class="comment">// Allow one task at a time to</span></span><br><span class="line">                                              <span class="comment">// access the first turnstile</span></span><br><span class="line">    count = count + <span class="number">1</span>; <span class="comment">// Increment count</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">5</span>) &#123;</span><br><span class="line">      osSemaphoreAcquire(Turnstile_Out,</span><br><span class="line">                         osWaitForever); <span class="comment">// Lock the second turnstile</span></span><br><span class="line">      osSemaphoreRelease(Turnstile_In);  <span class="comment">// Unlock the first turnstile</span></span><br><span class="line">    &#125;</span><br><span class="line">    osSemaphoreRelease(Mutex); <span class="comment">// Allow other tasks to access the turnstile</span></span><br><span class="line">    osSemaphoreAcquire(Turnstile_In, osWaitForever); <span class="comment">// Turnstile Gate</span></span><br><span class="line">    osSemaphoreRelease(Turnstile_In);</span><br><span class="line">    critical_Function();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们使用一个全局变量来计算到达屏障的线程数。当每个函数到达屏障时，它将等待直到它可以从计数器信号量中获取一个标记。一旦获得，计数变量将增加一。一旦我们增加了计数变量，一个标记被发送到计数器信号量，以便其他等待的线程可以继续。接下来，屏障代码读取计数变量。如果这等于等待到达屏障的线程数，我们将向屏障信号量发送一个标记。</p>
<p>在上面的例子中，我们同步了五个线程。前四个线程将增加计数变量，然后在屏障信号量处等待。第五个也是最后一个到达的线程将增加计数变量并向屏障信号量发送一个标记。这将允许它立即获取屏障信号量标记并继续执行。通过屏障后，它立即向屏障信号量发送另一个标记。这允许其他等待线程之一恢复执行。该线程在屏障信号量中放置另一个标记，触发另一个等待线程，依此类推。屏障代码的最后一部分称为旋转门，因为它一次允许一个线程通过屏障。在我们的并发执行模型中，这意味着每个线程都在屏障处等待，直到最后一个线程到达，然后所有线程同时恢复。在下面的练习中，我们为一个包含屏障代码的线程创建五个实例。但是，屏障可用于同步五个独特的线程。</p>
<h5 id="信号量警告"><a href="#信号量警告" class="headerlink" title="信号量警告"></a>信号量警告</h5><p>信号量是任何 RTOS 都非常有用的特性。然而，信号量可能会被滥用。您必须始终记住，信号量中的标记数量不是固定的。在程序运行期间，信号量标记可能会被创建和销毁。有时这很有用，但如果您的代码依赖于固定数量的信号量可用的标记，则必须非常小心，始终将标记返回给它。您还应该排除意外创建额外新标记的可能性。</p>
<h4 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h4><p>Mutex 代表“互斥”。实际上，互斥体是信号量的特殊版本。与信号量一样，互斥锁是标记的容器。不同之处在于互斥锁只能包含一个不能被创建或销毁的标记。互斥锁的主要用途是控制对外围设备等芯片资源的访问。出于这个原因，互斥体标记是二进制和有界的。除此之外，它的工作方式与信号量相同。首先我们必须声明互斥体容器并初始化互斥体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">osMutexId_t uart_mutex;</span><br><span class="line"> </span><br><span class="line">osMutexAttr_t &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;   <span class="comment">///&lt; name of the mutex</span></span><br><span class="line">  <span class="type">uint32_t</span> attr_bits; <span class="comment">///&lt; attribute bits</span></span><br><span class="line">  <span class="type">void</span> *cb_mem;       <span class="comment">///&lt; memory for control block</span></span><br><span class="line">  <span class="type">uint32_t</span> cb_size;   <span class="comment">///&lt; size of provided memory for control block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建互斥锁时，可以通过设置以下属性位来修改其功能：</p>
<table>
<thead>
<tr>
<th>Bitmask</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>osMutexRecursive</td>
<td>同一个线程可以多次使用互斥锁而不锁定自身。</td>
</tr>
<tr>
<td>osMutexPrioInherit</td>
<td>虽然线程拥有互斥锁，但它不能被更高优先级的线程抢占。</td>
</tr>
<tr>
<td>osMutexRobust</td>
<td>通知获取互斥锁的线程前一个所有者已终止。</td>
</tr>
</tbody></table>
<p>一旦声明了互斥锁，就必须在线程中创建。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uart_mutex = osMutexNew (&amp;MutexAttr);</span><br></pre></td></tr></table></figure>
<p>然后任何需要访问外设的线程必须首先获取互斥标记：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osMutexAcquire(osMutexId_t mutex_id,<span class="type">uint32_t</span> ticks);</span><br></pre></td></tr></table></figure>
<p>最后，当我们完成外围设备时，必须释放互斥锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osMutexRelease ( osMutexId_t mutex_id);</span><br></pre></td></tr></table></figure>
<p>互斥的使用比信号量的使用严格得多，但在控制对底层芯片寄存器的绝对访问时是一种更安全的机制。</p>
<h5 id="互斥警告"><a href="#互斥警告" class="headerlink" title="互斥警告"></a>互斥警告</h5><p>显然，当您完成芯片资源时，您必须小心返回互斥标记，否则您将有效地阻止任何其他线程访问它。您还必须非常小心地对控制互斥标记的函数使用osThreadTerminate()调用。Keil RTX5 被设计为占用空间很小的 RTOS，因此它甚至可以在非常小的 Cortex-M 微控制器上运行。因此，没有线程删除安全。这意味着如果您删除控制互斥标记的线程，您将销毁互斥标记并阻止对受保护外围设备的任何进一步访问。</p>
<h4 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h4><p>到目前为止，所有的线程间通信方式都只用于触发线程的执行；它们不支持线程之间的程序数据交换。显然，在实际程序中，我们需要在线程之间移动数据。这可以通过读取和写入全局声明的变量来完成。除了一个非常简单的程序外，试图保证数据完整性将是极其困难的，并且容易出现不可预见的错误。线程之间的数据交换需要更正式的异步通信方法。</p>
<p><strong>CMSIS-RTOS 提供了两种线程间数据传输的方法</strong>。第一种方法是一个消息队列，它在两个线程之间创建一个缓冲数据“管道”。消息队列旨在传输整数值。</p>
<p>数据传输的第二种形式是邮件队列。这与消息队列非常相似，不同之处在于它传输数据块而不是单个整数。</p>
<p>消息队列和邮件队列都提供了一种在线程之间传输数据的方法。这允许您将设计视为由数据流互连的对象（线程）的集合。数据流由消息和邮件队列实现。这提供了数据的缓冲传输和线程之间定义良好的通信接口。从基于邮件和消息队列连接的线程的系统级设计开始，您可以对项目的不同子系统进行编码，如果您在团队中工作，这尤其有用。此外，由于每个线程都有明确定义的输入和输出，因此很容易隔离以进行测试和代码重用。</p>
<h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><p>要设置消息队列，我们​​首先需要分配内存资源：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">osMessageQId_t Q_LED;</span><br><span class="line"> </span><br><span class="line">osMessageQueueAttr_t &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;   <span class="comment">///&lt; name of the message queue</span></span><br><span class="line">  <span class="type">uint32_t</span> attr_bits; <span class="comment">///&lt; attribute bits</span></span><br><span class="line">  <span class="type">void</span> *cb_mem;       <span class="comment">///&lt; memory for control block</span></span><br><span class="line">  <span class="type">uint32_t</span> cb_size;   <span class="comment">///&lt; size of provided memory for control block</span></span><br><span class="line">  <span class="type">void</span> *mq_mem;       <span class="comment">///&lt; memory for data storage</span></span><br><span class="line">  <span class="type">uint32_t</span> mq_size;   <span class="comment">///&lt; size of provided memory for data storage</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一旦声明了消息队列句柄和属性，我们就可以在线程中创建消息队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q_LED = osMessageNew(DepthOfMesageQueue,WidthOfMessageQueue,&amp;osMessageQueueAttr);</span><br></pre></td></tr></table></figure>
<p>创建消息队列后，我们可以将数据从一个线程放入队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osMessageQueuePut (Q_LED,&amp;dataIn,messagePrioriy, osWaitForever );</span><br></pre></td></tr></table></figure>
<p>然后从另一个队列中读取：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = osMessageQueueGet(Q_LED,&amp;dataOut,messagePriority,osWaitForever);</span><br></pre></td></tr></table></figure>

<h5 id="扩展消息队列"><a href="#扩展消息队列" class="headerlink" title="扩展消息队列"></a>扩展消息队列</h5><p>在上一个例子中，我们定义了一个字宽的消息队列。如果您需要发送大量数据，还可以定义一个消息队列，其中每个插槽可以容纳更复杂的数据。首先，我们可以定义一个结构来保存我们的消息数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> duration;</span><br><span class="line">  <span class="type">uint32_t</span> ledNumber;</span><br><span class="line">  <span class="type">uint8_t</span> priority;</span><br><span class="line">&#125; <span class="type">message_t</span>;</span><br></pre></td></tr></table></figure>
<p>然后我们可以定义一个消息队列，它被格式化为接收这种类型的消息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q_LED = osMessageQueueNew (<span class="number">16</span>, <span class="keyword">sizeof</span> (<span class="type">message_t</span>),&amp;queueAttr_Q_LED );  </span><br></pre></td></tr></table></figure>

<h5 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h5><p>我们可以设计一个消息队列来支持大量数据的传输。然而，这种方法有一个开销，因为我们正在“移动”队列中的数据。在本节中，我们将着眼于设计<strong>一个数据保持静态的更高效的“零拷贝”邮箱</strong>。CMSIS-RTOS2 支持以固定块内存池的形式动态分配内存。首先，我们可以声明内存池属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">osMemoryPoolAttr_t &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;   <span class="comment">///&lt; name of the memory pool</span></span><br><span class="line">  <span class="type">uint32_t</span> attr_bits; <span class="comment">///&lt; attribute bits</span></span><br><span class="line">  <span class="type">void</span> *cb_mem;       <span class="comment">///&lt; memory for control block</span></span><br><span class="line">  <span class="type">uint32_t</span> cb_size;   <span class="comment">///&lt; size of provided memory for control block</span></span><br><span class="line">  <span class="type">void</span> *mp_mem;       <span class="comment">///&lt; memory for data storage</span></span><br><span class="line">  <span class="type">uint32_t</span> mp_size;   <span class="comment">///&lt; size of provided memory for data storage</span></span><br><span class="line">&#125; osMemoryPoo</span><br></pre></td></tr></table></figure>
<p>以及内存池的句柄：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osMemoryPoolId_t mpool;</span><br></pre></td></tr></table></figure>
<p>对于内存池本身，我们需要声明一个结构，其中包含我们在每个内存池中需要的内存元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> LED0;</span><br><span class="line">  <span class="type">uint8_t</span> LED1;</span><br><span class="line">  <span class="type">uint8_t</span> LED2;</span><br><span class="line">  <span class="type">uint8_t</span> LED3;</span><br><span class="line">&#125; <span class="type">memory_block_t</span>;</span><br></pre></td></tr></table></figure>
<p>然后我们可以在我们的应用程序代码中创建一个内存池：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpool = osMemoryPoolNew (<span class="number">16</span>, <span class="keyword">sizeof</span> (<span class="type">message_t</span>),&amp;memorypoolAttr_mpool);</span><br></pre></td></tr></table></figure>
<p>现在我们可以在一个线程中分配一个内存池槽：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">memory_block_t</span> *led_data;</span><br><span class="line">led_data = (<span class="type">memory_block_t</span> *) osMemoryPoolAlloc (mPool, osWaitForever );</span><br></pre></td></tr></table></figure>
<p>然后用数据填充它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">led_data-&gt;LED0 = <span class="number">0</span>;</span><br><span class="line">led_data-&gt;LED1 = <span class="number">1</span>;</span><br><span class="line">led_data-&gt;LED2 = <span class="number">2</span>;</span><br><span class="line">led_data-&gt;LED3 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>然后可以将指向内存块的指针放在消息队列中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osMessagePut(Q_LED,(<span class="type">uint32_t</span>)led_data, osWaitForever );</span><br></pre></td></tr></table></figure>
<p>现在可以通过另一个任务访问数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">osEvent event;</span><br><span class="line"><span class="type">memory_block_t</span> *received;</span><br><span class="line">event = osMessageGet(Q_LED, osWatiForever);</span><br><span class="line"> received = (memory_block *)event.value.p;</span><br><span class="line">led_on(received-&gt;LED0);</span><br></pre></td></tr></table></figure>
<p>一旦内存块中的数据被使用，该块必须释放回内存池以供重用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osPoolFree(led_pool,received);</span><br></pre></td></tr></table></figure>
<p>为了创建零副本邮箱系统，我们可以将存储数据的内存池与用于传输指向已分配内存池槽的指针的消息队列结合起来。这样消息数据保持静态，我们<strong>在线程之间传递一个指针</strong>。备注：其实这里和rtthread的邮箱操作十分的相识，都是传递的指针。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>到目前为止，我们已经了解了 CMSIS-RTOS2 API。这包括线程管理功能、时间管理和线程间通信。现在我们已经清楚地了解了 RTOS 内核的功能，我们可以更详细地查看配置文件。</p>
<p>RTX_Config.h 是所有基于 Cortex-M 的微控制器的中央配置文件。与其他配置文件一样，它是一个模板文件，它将所有必要的配置呈现为一组菜单选项（在配置向导视图中查看时）。</p>
<h4 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h4><p>在我们讨论系统配置部分中的设置之前，值得一提的是缺少什么。在 CMSIS-RTOS 的早期版本中，有必要将 CPU 频率定义为 RTOS 配置的一部分。在 CMSIS-RTOS2 中，CPU 频率现在取自“SystemCoreClock”变量，该变量被设置为 CMSIS-Core 系统启动代码的一部分。如果您使用的是新微控制器，则需要检查该值是否设置正确。</p>
<p>正如我们之前看到的，我们可以设置分配给“全局动态内存池”的内存量。接下来，我们可以定义以赫兹为单位的滴答频率。这定义了 SysTick 中断率，默认设置为 1 ms。通常，我会将这个频率保留为默认设置。然而，处理器时钟速度变得越来越快。如果您使用的是高性能设备，您可以考虑使用更快的滴答率。</p>
<p>“循环线程”切换在此部分中也默认启用。同样，我建议将这些设置保留为默认状态，除非您强烈要求更改它们。系统配置设置还允许我们在 RTOS 运行时控制发送到事件记录器的消息范围。</p>
<p>最后，如果我们从中断中设置线程标志，它们将被保留在队列中，直到它们被处理。根据您的应用程序，您可能需要增加此队列的大小。</p>
<h4 id="线程配置"><a href="#线程配置" class="headerlink" title="线程配置"></a>线程配置</h4><p>在线程配置部分，我们定义了 CMSIS-RTOS2 线程所需的基本资源。我们为每个线程分配一个“默认线程堆栈空间”（默认情况下，这是 200 字节）。当您创建线程时，将从全局动态 Mmemory 池分配此内存。但是，如果我们启用对象特定的内存分配，RTOS 将定义一个专用于线程使用的内存区域。如果切换到对象特定的内存分配，则需要提供有关线程内存数量和大小的详细信息，以便 RTOS 可以计算最大内存需求。</p>
<p>对于特定于对象的内存分配，我们必须定义将运行的最大用户线程数（不计算空闲或计时器线程）。我们还必须定义具有默认堆栈大小的线程数以及具有自定义粘性大小的线程所需的总内存量。一旦我们定义了用户线程使用的内存，我们就可以为空闲线程分配内存。在开发过程中，CMSIS-RTOS 可以捕获堆栈溢出。启用此选项时，线程堆栈空间溢出将导致 RTOS 内核调用osRtxErrorNotify()位于 RTX_Config.c 文件中的函数。此函数获取错误代码，然后陷入无限循环。堆栈检查选项旨在在调试期间使用，应在最终应用程序中禁用以最小化内核开销。但是，如果最终版本中需要增强错误保护，则可以修改osRtxErrorNotify()函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OS Error Callback function</span></span><br><span class="line">__WEAK <span class="type">uint32_t</span> <span class="title function_">osRtxErrorNotify</span> <span class="params">(<span class="type">uint32_t</span> code, <span class="type">void</span> *object_id)</span> &#123;</span><br><span class="line">  (<span class="type">void</span>)object_id;</span><br><span class="line">  <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> osRtxErrorStackUnderflow:</span><br><span class="line">      <span class="comment">// Stack overflow detected for thread (thread_id=object_id)</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> osRtxErrorISRQueueOverflow:</span><br><span class="line">      <span class="comment">// ISR Queue overflow detected when inserting object (object_id)</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> osRtxErrorTimerQueueOverflow:</span><br><span class="line">      <span class="comment">// User Timer Callback Queue overflow detected for timer (timer_id=object_id)</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> osRtxErrorClibSpace:</span><br><span class="line">      <span class="comment">// Standard C/C++ library libspace not available: increase OS_THREAD_LIBSPACE_NUM</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> osRtxErrorClibMutex:</span><br><span class="line">      <span class="comment">// Standard C/C++ library mutex initialization failed</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// Reserved</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;&#125;</span><br><span class="line"><span class="comment">//return 0U;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以在运行时监视最大堆栈内存使用情况。如果您选中“堆栈使用水印”选项，则会将模式 (0xCC) 写入每个堆栈空间。在运行期间，此水印用于计算最大内存使用量。在 Arm Keil MDK 中，这个数字是在 View - Watch Window - RTX RTOS 窗口的线程部分报告的。</p>
<p>此部分还允许我们选择线程是在特权模式还是非特权模式下运行。最后一个选项允许我们为用户线程定义处理器操作模式。如果您想要轻松的生活，请将其设置为“特权模式”，您将可以完全访问所有处理器功能。但是，如果您正在编写安全关键或安全应用程序，则可以使用“非特权模式”来防止线程访问关键处理器寄存器，从而限制运行时错误或入侵尝试。</p>
<h4 id="系统定时器配置"><a href="#系统定时器配置" class="headerlink" title="系统定时器配置"></a>系统定时器配置</h4><p>与 CMSIS-RTOS 一起使用的默认计时器是 Cortex-M SysTick 计时器，它几乎存在于所有 Cortex-M 处理器上。SysTick 定时器的输入通常是 CPU 时钟。可以通过重载内核计时器函数来使用不同的计时器，如OS Tick API文档中所述。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在本教程中，我们已经完成了 CMSIS-RTOS2 API，并介绍了一些与使用 RTOS 相关的关键概念。<strong>学习如何使用 RTOS 进行开发的唯一真正方法是在实际项目中实际使用它</strong>。</p>
<h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><p><a target="_blank" rel="noopener" href="https://arm-software.github.io/CMSIS_5/RTOS2/html/rtos2_tutorial.html">CMSIS_RTOS2_Tutorial</a></p>
<p>That’s all.Check it.</p>

        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                    <a class="donate" href="javascript:;"><i class="fa fa-bitcoin"></i> 打赏</a>
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "https://zhekunren.github.io/archives/3b27166f.html",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://zhekunren.github.io/archives/3b27166f.html";
            const title         = "「RTX_RTOS之01-CMSIS_RTOS2_Tutorial自译中文版」";
            const excerpt       = ``;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/RTOS/" rel="tag">RTOS</a>, <a class="tag-none-link" href="/tags/RTX/" rel="tag">RTX</a>
                </div>
                <div class="pull-date">
                <span>最后编辑：2022-01-23</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" RTX_RTOS之00-STM32CUBMX创建MDK工程移植RTX5源码" href="/archives/572b9c96.html">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" RTX_RTOS之02-CMSIS_RTOS2_Reference自译中文版" href="/archives/9c7b2d17.html">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
        <div id="disqus_thread" class="post-comments lazy-load"></div>

<script>
    var disqus_config = function () {
        this.page.url = 'https://zhekunren.github.io/archives/3b27166f.html';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'archives/3b27166f.html'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    var load_comm = () => {
        if (typeof DISQUS === 'undefined') {
            var d = document, s = d.createElement('script');
            s.src = 'https://zhekunblog.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        } else {
            DISQUS.reset({
                reload: true,
                config: function () {  
                    this.page.url = 'https://zhekunren.github.io/archives/3b27166f.html';  // Replace PAGE_URL with your page's canonical URL variable
                    this.page.identifier = 'archives/3b27166f.html'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                }
            });
        }
    };
    
</script>
<script async id="dsq-count-scr" src="//zhekunblog.disqus.com/count.js"></script>

<noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <!-- <div class="photo-background"></div> --> <!-- 删除头像处banner图片，将这行代码替换成下一行 delete by zhekun-->
    <div style="height: 75px;"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="https://cdn.jsdelivr.net/gh/zhekunren/blog_image/img/theme/avatar2.jpg" />
        </div>
    </div>
    <!-- <div class="textwidget">
        <p class="text-center">与其向往，不如出发</p> 
    </div> -->
    <!-- 重定义about界面，将这行代码替换成下一行 delete by zhekun-->
    <div><p style="margin-top:10px;margin-bottom:0;text-align:center;font-weight:400;font-size:25px;line-height:1.5;">zhekunのblog</p><p style="margin-top:0;margin-bottom:0;text-align:center;font-size:15px;line-height:1.5;">与其向往，不如出发</p><p style="margin-top:0;margin-bottom:0;text-align:center;font-size:15px;line-height:1.5;"><i class="fa fa-map-marker"></i><span>中国●四川</span></p></div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                54
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                12
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                23
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%99%E7%A8%8B"><span class="toc-text">教程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Keil-RTX5-%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5"><span class="toc-text">使用 Keil RTX5 的第一步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-CMSIS-RTOS2-API"><span class="toc-text">访问 CMSIS-RTOS2 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">启动实时操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">线程管理和优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="toc-text">多个实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-text">可连接的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-text">时间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%BB%B6%E8%BF%9F"><span class="toc-text">时间延迟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E6%97%B6%E9%97%B4%E5%BB%B6%E8%BF%9F"><span class="toc-text">绝对时间延迟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">虚拟定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%BA%BF%E7%A8%8B"><span class="toc-text">空闲线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">线程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%87%E5%BF%97"><span class="toc-text">线程标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97"><span class="toc-text">事件标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">使用信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B"><span class="toc-text">同步线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">多路复用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%9A%E5%90%88-%E9%9B%86%E5%90%88"><span class="toc-text">会合(集合)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9C"><span class="toc-text">屏障</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%AD%A6%E5%91%8A"><span class="toc-text">信号量警告</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93"><span class="toc-text">互斥体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E8%AD%A6%E5%91%8A"><span class="toc-text">互斥警告</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2"><span class="toc-text">数据交换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">扩展消息队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-text">内存池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-text">配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE"><span class="toc-text">系统配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%85%8D%E7%BD%AE"><span class="toc-text">线程配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AE%9A%E6%97%B6%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">系统定时器配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83"><span class="toc-text">相关参考</span></a></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/EOS-RTOS/">EOS-RTOS</a><span class="category-list-count">14</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/EOS-RTOS/FreeRTOS/">FreeRTOS</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/EOS-RTOS/RTX/">RTX</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">嵌入式开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/">技术积累</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B1%82%E8%81%8C%E7%AC%94%E8%AE%B0/">求职笔记</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/">生活日常</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/%E5%BD%B1%E9%9F%B3%E7%BE%8E%E5%9B%BE/">影音美图</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/">软件工具</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Hexo/">Hexo</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/">安装破解</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/">实用工具</a><span class="category-list-count">1</span></li></ul></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/C-Cpp/" style="font-size: 0.63em;">C&Cpp</a> <a href="/tags/DMA/" style="font-size: 0.66em;">DMA</a> <a href="/tags/FIFO/" style="font-size: 0.63em;">FIFO</a> <a href="/tags/FreeRTOS/" style="font-size: 0.77em;">FreeRTOS</a> <a href="/tags/MathType/" style="font-size: 0.6em;">MathType</a> <a href="/tags/Matlab/" style="font-size: 0.6em;">Matlab</a> <a href="/tags/Mysql/" style="font-size: 0.6em;">Mysql</a> <a href="/tags/QT/" style="font-size: 0.6em;">QT</a> <a href="/tags/RTOS/" style="font-size: 0.8em;">RTOS</a> <a href="/tags/RTX/" style="font-size: 0.66em;">RTX</a> <a href="/tags/XMind/" style="font-size: 0.6em;">XMind</a> <a href="/tags/blog-test/" style="font-size: 0.71em;">blog-test</a> <a href="/tags/blog-tips/" style="font-size: 0.66em;">blog-tips</a> <a href="/tags/hexo/" style="font-size: 0.74em;">hexo</a> <a href="/tags/install/" style="font-size: 0.69em;">install</a> <a href="/tags/life/" style="font-size: 0.63em;">life</a> <a href="/tags/movies/" style="font-size: 0.63em;">movies</a> <a href="/tags/muisc/" style="font-size: 0.6em;">muisc</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/archives/4fd3c7f0.html"><i class="fa  fa-book"></i> Mysql安装与基础使用（QT、Matlab）</a>
            
          
        
          
          
            <a class="list-group-item" href="/archives/e1e589cc.html"><i class="fa  fa-book"></i> 求职笔记--专栏索引</a>
            
          
        
          
          
        
          
          
            <a class="list-group-item" href="/archives/428d3437.html"><i class="fa  fa-book"></i> Hexo blog custom record</a>
            
          
        
          
          
            <a class="list-group-item" href="/archives/c4a4928.html"><i class="fa  fa-book"></i> 常用在线工具（不定期更新）</a>
            
          
        
          
          
            <a class="list-group-item" href="/archives/fb0c4ff4.html"><i class="fa  fa-book"></i> 影音美图畅享（不定期更新）</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        <li><a title="mail" href="mailto:zhekunren@qq.com"><i class="fa fa-envelope"></i></a></li>
                        
                        
                        
                        
                        
                        <li><a title="github" target="_blank" rel="nofollow" href="https://github.com/zhekunren"><i class="fa fa-github"></i></a></li>
                        <li><a title="gitee" target="_blank" rel="nofollow" href="https://gitee.com/zhekunren"><i class="fa fa-github-alt"></i></a></li>
                        <li><a title="rss" target="_blank" rel="nofollow" href="/atom.xml"><i class="fa fa-rss"></i></a></li>
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 zhekunのblog 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <!-- <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by zhekun.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div> -->
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://unpkg.com/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://unpkg.com/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>

    <div>
        <canvas id="snow"></canvas>
        <script async type="text/javascript" src="/js/snow.min.js"></script>
    </div>


    <script async src="/js/candy.min.js"></script>



    <script defer src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://unpkg.com/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="7230595307"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://unpkg.com/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>

    <script defer src="https://unpkg.com/layui-src@2.5.5/dist/layui.all.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>


<script type="text/javascript">document.write(unescape("%3Cspan style='display:none;' id='cnzz_stat_icon_1280860084'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1280860084' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Extra support for third-party plguins  -->


    </body>
</html>